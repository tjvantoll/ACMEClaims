//-------------------------------------------------------------------------
// <Auto-generated file - do not modify!>
//
// This code was generated automatically by Kinvey Studio.
//
// Changes to this file may cause undesired behavior and will be lost
// the next time the code regenerates.
//
// Find more information on https://devcenter.kinvey.com/guides/studio-extension-points.
//-------------------------------------------------------------------------
import { Params, convertToParamMap } from '@angular/router';
import { Observable, ConnectableObservable, BehaviorSubject, Subject, of } from 'rxjs';
import { first, publish, catchError, map, filter } from 'rxjs/operators';

import { ModelDataResult } from '@src/app/core/data/model-data-result';
import { DataStateService } from '@src/app/core/data/state/data-state.service';
import { EntityState } from '@src/app/core/data/state/entity-state.interface';

export abstract class BaseDataService<T, TConfig, TState> {
    public readonly dataState: DataStateService<TState>;

    public get dataChanges(): Observable<ModelDataResult<T> | T[] | T> {
        if (!this._dataChanges) {
            this._dataChanges = this.getDataChanges();
        }

        return this._dataChanges
    }

    public readonly errors = new BehaviorSubject<Error>(null);
    public readonly isLoading = new Subject<boolean>();

    private _dataChanges: Observable<ModelDataResult<T> | T[] | T>;

    constructor(protected config: TConfig, initialState?: TState, public readonly typeName?: string) {
        this.dataState = new DataStateService<TState>(initialState);
    }

    public abstract refresh(): Promise<any>;

    public mapParams(params: Observable<Params>): Observable<EntityState> {
        return params.pipe(
            map((params: Params) => {
                const paramMap = convertToParamMap(params);
                const idParam = `${this.typeName}Id`

                return paramMap.has(idParam) ? { id: paramMap.get(idParam) } : null;
            }),
            filter(v => !!v)
        );
    }

    protected abstract getDataChanges(): Observable<any>;

    protected toPromise(action: () => void) {
        const connectableObservable = this.dataChanges.pipe(publish()) as ConnectableObservable<any>;
        connectableObservable.connect();
        action();

        return connectableObservable.pipe(first()).toPromise();
    }

    protected handleError(error: Error) {
        this.isLoading.next(false);
        this.errors.next(error);
        console.error(error.stack || error.toString());
    }

    protected handleObservableError() {
        return catchError((error: Error) => {
            this.handleError(error);
            return of(null);
        });
    }

    protected handlePromiseError(error: Error) {
        this.handleError(error);
        throw error;
    }
}
